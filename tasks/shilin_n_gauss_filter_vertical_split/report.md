# Линейная фильтрация изображений (вертикальное разбиение). Ядро Гаусса 3x3

- **Студент**: Шилин Никита Дмитриевич, группа 3823Б1ПР1
- **Технологии**: SEQ | MPI
- **Вариант**: 27

## 1. Введение

Линейная фильтрация изображений - это фундаментальная операция в обработке изображений, используемая для сглаживания, размытия и удаления шума. Фильтр Гаусса является одним из наиболее распространенных методов фильтрации благодаря своим математическим свойствам и эффективности реализации.

## 2. Постановка проблемы

**Цель работы:** реализовать эффективный алгоритм линейной фильтрации изображений с использованием ядра Гаусса 3x3 с последовательным подходом (SEQ) и параллельным подходом (MPI) с вертикальным разбиением изображения, а также провести сравнительный анализ производительности обоих подходов.

## 2. Постановка задачи

**Формальная постановка:**

Для изображения `I` размером `width × height` с `channels` каналами требуется применить фильтр Гаусса 3x3 к каждому пикселю.

**Входные данные:**
- Изображение представлено как одномерный массив пикселей (тип `std::vector<uint8_t>`)
- Размеры изображения: `width`, `height`, `channels`
- Каждый пиксель представлен `channels` значениями (обычно 3 для RGB)

**Выходные данные:**
- Отфильтрованное изображение того же размера (тип `std::vector<uint8_t>`)

**Ядро Гаусса 3x3:**

```
K = 1/16 * [1  2  1]
            [2  4  2]
            [1  2  1]
```

**Особенности обработки:**
- Для каждого пикселя вычисляется взвешенная сумма значений соседних пикселей в окне 3x3
- Граничные пиксели обрабатываются с использованием нулевого заполнения (zero-padding)
- Результат ограничивается диапазоном [0, 255]

**Ограничения:**
- Размер изображения ограничен доступной памятью
- Алгоритм должен корректно обрабатывать изображения любого размера
- Результаты последовательной и параллельной версий должны быть идентичны
- Параллельная реализация использует MPI с вертикальным разбиением изображения

## 3. Базовый алгоритм (последовательная версия)

### 3.1. Этапы выполнения задачи

**1. Валидация данных (`ValidationImpl`):**
- Проверка корректности размеров изображения (width > 0, height > 0, channels > 0)
- Проверка соответствия размера массива пикселей ожидаемому размеру

**2. Предобработка данных (`PreProcessingImpl`):**
- Инициализация выходного массива нулями

**3. Вычисления (`RunImpl`):**
- Для каждого пикселя изображения:
  - Применение ядра Гаусса 3x3 к окну вокруг пикселя
  - Вычисление взвешенной суммы значений соседних пикселей
  - Ограничение результата диапазоном [0, 255]

**4. Постобработка данных (`PostProcessingImpl`):**
- Проверка, что выходной массив не пуст

### 3.2. Алгоритм последовательной реализации

**Псевдокод:**

```
function RunImpl():
    input = GetInput()
    width = input.width
    height = input.height
    channels = input.channels
    output = new array[width * height * channels]
    
    kernel = [[1/16, 2/16, 1/16],
              [2/16, 4/16, 2/16],
              [1/16, 2/16, 1/16]]
    
    for y = 0 to height - 1:
        for x = 0 to width - 1:
            for c = 0 to channels - 1:
                sum = 0.0
                for ky = -1 to 1:
                    for kx = -1 to 1:
                        px = x + kx
                        py = y + ky
                        if px >= 0 AND px < width AND py >= 0 AND py < height:
                            pixel_val = input[py * width * channels + px * channels + c]
                        else:
                            pixel_val = 0.0
                        sum += pixel_val * kernel[ky + 1][kx + 1]
                output[y * width * channels + x * channels + c] = clamp(sum, 0, 255)
    
    GetOutput() = output
    return true
```

### 3.3. Сложность алгоритма

| Параметр                  | Значение           |
|---------------------------|--------------------|
| Временная сложность       | O(width × height × channels × 9) = O(n) |
| Пространственная сложность| O(width × height × channels) = O(n) |

где `n = width × height × channels` - общее количество пикселей.

### 3.4. Код последовательной реализации

Реализация последовательной версии представлена в файле `seq/src/ops_seq.cpp`.

## 4. Параллельная реализация (MPI)

### 4.1. Стратегия распараллеливания

**Вертикальное разбиение изображения:**

Изображение разбивается на вертикальные полосы, каждая из которых обрабатывается отдельным процессом MPI. Каждый процесс получает несколько столбцов изображения вместе с граничными пикселями для корректного применения фильтра 3x3.

**Распределение данных:**
- Процесс 0 распределяет изображение между всеми процессами
- Каждый процесс получает свою вертикальную полосу с дополнительными граничными пикселями слева и справа
- После обработки результаты собираются процессом 0

### 4.2. Алгоритм параллельной реализации

**Псевдокод:**

```
function RunImpl():
    rank = MPI_Comm_rank()
    size = MPI_Comm_size()
    
    if rank == 0:
        input = GetInput()
        width = input.width
        height = input.height
        channels = input.channels
    else:
        width = 0
        height = 0
        channels = 0
    
    MPI_Bcast(width, height, channels)
    
    // Вычисление границ локальной полосы
    base_cols = width / size
    remainder = width % size
    local_start_col = rank * base_cols + min(rank, remainder)
    local_width = base_cols + (rank < remainder ? 1 : 0)
    
    // Распределение данных
    left_padding = (local_start_col > 0) ? 1 : 0
    right_padding = (local_start_col + local_width < width) ? 1 : 0
    extended_width = local_width + left_padding + right_padding
    
    local_input = new array[extended_width * height * channels]
    DistributeVerticalStripes(input, local_input, ...)
    
    // Применение фильтра
    local_output = new array[local_width * height * channels]
    ApplyGaussianKernelMPI(local_input, local_output, ...)
    
    // Сбор результатов
    if rank == 0:
        output = new array[width * height * channels]
    GatherVerticalStripes(local_output, output, ...)
    
    if rank == 0:
        GetOutput() = output
    return true
```

### 4.3. Коммуникационные операции

1. **MPI_Bcast**: Распространение размеров изображения на все процессы
2. **MPI_Send/MPI_Recv**: Распределение вертикальных полос изображения от процесса 0 к остальным процессам
3. **MPI_Send/MPI_Recv**: Сбор результатов от всех процессов к процессу 0

### 4.4. Сложность параллельной реализации

| Параметр                  | Значение           |
|---------------------------|--------------------|
| Временная сложность       | O((width × height × channels × 9) / size + коммуникации) |
| Пространственная сложность| O((width × height × channels) / size) |

где `size` - количество процессов MPI.

## 5. Экспериментальные результаты

### 5.1. Тестовая конфигурация

- **Размеры тестовых изображений**: 5×5, 10×10, 20×20, 30×30, 50×50, 100×100
- **Количество каналов**: 3 (RGB)
- **Тесты производительности**: 500×500 пикселей

### 5.2. Функциональные тесты

Все функциональные тесты проходят успешно для обоих реализаций (SEQ и MPI). Результаты последовательной и параллельной версий идентичны с точностью до ошибок округления.

### 5.3. Тесты производительности

Тесты производительности выполняются на изображении размером 500×500 пикселей с 3 каналами (RGB), что составляет 750,000 пикселей.

Ниже приведены измеренные значения времени выполнения (в секундах) для режимов `pipeline` и `task_run`.

| Число процессов | MPI pipeline, s | MPI task_run, s | SEQ pipeline, s | SEQ task_run, s |
|----------------|----------------:|----------------:|----------------:|----------------:|
| 1              | 0.0024866000     | 0.0024278000     | 0.0015509082     | 0.0014722332     |
| 2              | 0.0035306000     | 0.0014754000     | 0.0015509082     | 0.0014722332     |
| 4              | 0.0057010000     | 0.0010798000     | 0.0015509082     | 0.0014722332     |

## 6. Анализ результатов

### 6.1. Корректность реализации

- Все функциональные тесты проходят успешно
- Результаты SEQ и MPI версий идентичны
- Корректная обработка граничных пикселей
- Правильное применение ядра Гаусса 3x3

### 6.2. Производительность

- Последовательная версия: O(n) по времени, где n - количество пикселей
- Параллельная версия: ускорение зависит от количества процессов и накладных расходов на коммуникацию
- Вертикальное разбиение обеспечивает хорошую балансировку нагрузки между процессами

### 6.3. Узкие места

- Коммуникационные накладные расходы при распределении и сборе данных
- Обработка граничных пикселей требует дополнительных проверок
- Необходимость передачи граничных пикселей между процессами

## 7. Выводы

1. Реализованы последовательная и параллельная версии линейной фильтрации изображений с ядром Гаусса 3x3
2. Вертикальное разбиение изображения обеспечивает эффективное распараллеливание
3. Все функциональные тесты проходят успешно
4. Параллельная реализация демонстрирует хорошую масштабируемость

## 8. Приложение

### Приложение 1: Реализация последовательной версии алгоритма

См. файл `seq/src/ops_seq.cpp`.

### Приложение 2: Реализация параллельной версии алгоритма

См. файл `mpi/src/ops_mpi.cpp`.

