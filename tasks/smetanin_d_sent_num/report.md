# Подсчет числа предложений в строке Сметанин Дмитрий

- Student: Сметанин Дмитрий Владимирович, 3823Б1ПР3
- Technology: SEQ | MPI
- Variant: 25

## 1. Introduction
В данной работе реализованы последовательный подход (SEQ) и параллельный подход с использованием технологии MPI.

Цель - разработать эффективный алгоритм подсчёта предложений в строке, реализовать его последовательную и параллельную версии, а также провести сравнительный анализ производительности обоих подходов на реальных данных.

## 2. Problem Statement
Задача - подсчет числа предложений в текстовой строке.

Входные данные - строка произвольной длины (тип std::string).
Выходные данные - целое число - количество предложений в строке (тип std::size_t).

Предложение считается завершённым, если оно заканчивается одним из следующих знаков препинания: точка (.), тосклицательный знак, (!), вопросительный знак (?).

Особенности обработки:

Последовательные знаки препинания (например, ..., !!!) считаются как несколько предложений (каждый знак отдельно).
Смешанная пунктуация (например, .!?) также считается как несколько предложений.
Строка без завершающих знаков препинания содержит 0 предложений.
Пустая строка содержит 0 предложений.

Ограничения:

Строка не может быть пустой.
Алгоритм должен корректно обрабатывать ASCII символы.
Параллельная реализация использует MPI и должна поддерживать различное количество процессов.

## 3. Baseline Algorithm (Sequential)
Один проход по строке, считаем границы предложений по встрече терминаторов . ! ? — увеличиваем счётчик,
только если перед ними не было другого терминатора (чтобы не считать ... или !! несколько раз). Алгоритм работает за O(N).
Псевдокод:

```знерщт
terminators = {'.', '!', '?'}

if length(string) > 0 and string[0] in terminators:
  string[0] = ' '

count = 0

for i from 0 to length(string)-1:
  c = string[i]
  if c in terminators:
    if i == 0:
      continue
    prev = string[i-1]
    if prev not in terminators:
      count += 1

return count
```

Поддержка UTF-8/emoji: корректно, т.к. алгоритм проверяет только ASCII-символы терминаторов и пробельность, многобайтные символы не ломают логику.

## 4. Parallelization Scheme
Распределение данных:
```
N = length(string)
P = num_processes

base = N / P
rem  = N % P

begin = rank * base + min(rank, rem)
end   = begin + base + (rank < rem ? 1 : 0)
```

Коммуникация:
В упрощённой модели вся строка доступна всем процессам (простота реализации).
Каждый процесс считает предложения в своём сегменте; для корректного учёта границ смотрит символ перед `begin`.
Сбор результатов коллективной операцией:
```
MPI_Allreduce(&local_count, &global_count, 1, MPI_UNSIGNED_LONG_LONG, MPI_SUM, MPI_COMM_WORLD)
```

Роли рангов:
Rank 0: вывод результата, участвует в коллективных операциях.
Rank 1..P-1: подсчёт локального `local_count`, участвуют в объединении.

Учет границ:
Если `begin > 0`, перед началом обработки процесс проверяет `string[begin-1]`.
Если предыдущий символ не терминатор — тогда первый терминатор в локальном сегменте считается началом предложения, иначе — нет.

```
local_count = 0
for pos in [begin, end):
  if string[pos] in {'.','!','?'}:
    if pos == 0: continue
    if string[pos-1] not in {'.','!','?'}:
      local_count += 1

MPI_Allreduce(local_count -> global_count)
```

## 5. Implementation Details
tasks\smetanin_d_sent_num\
├── common
│ └── include
│ └── common.hpp
├── info.json
├── mpi
│   ├── include
│   │   └── ops_mpi.hpp
│   └── src
│       └── ops_mpi.cpp
├── report.md
├── seq
│   ├── include
│   │   └── ops_seq.hpp
│   └── src
│       └── ops_seq.cpp
├── settings.json
└── tests
    ├── functional
    │   └── functional.cpp
    └── performance
        └── performance.cpp

Ключевые классы и функции:
SmetaninDSentNumSEQ — последовательная реализация.
SmetaninDSentNumMPI — MPI-реализация.

Основные методы (общие для обоих):
ValidationImpl() — проверка входа.
PreProcessingImpl() — корректировка начала строки.
RunImpl() — основной алгоритм.
PostProcessingImpl() — финальная проверка/установка результата.

## 6. Experimental Setup
Hardware/OS: AMD Ryzen 5 5600H, Cores/Threads: 6/12, 16GB RAM, Windows 11 x64.
Toolchain: Microsoft Visual C++, Visual Studio Code 2019/2022, Release, Microsoft MPI 10.1.
Environment: mpiexec -n N, MPI_COMM_WORLD.
Data: 
Функциональные тесты:
test_0.txt: 0 предложений.
test_1.txt: 1 предложений.
test_2.txt: 4 предложений.
test_3.txt: 100 предложений.
test_4.txt: 1 предложений.
Производительность:
test_5.txt: 100,000 предложений (~3.7 MB).
Размер: 3,700,756 байт.

## 7. Results and Discussion

### 7.1 Correctness
Проверка корректности через функциональные тесты (10 тестов).
Сравнение MPI и SEQ для всех вариантов.
Все тесты в SEQ и MPI пройдены успешно.

### 7.2 Performance
Speedup = Time_seq / Time_mpi.
Efficiency = Speedup / Count * 100%.

Показатели:

Pipeline
| Mode | Count | Time, s    | Speedup | Efficiency |
|------|------:|-----------:|--------:|-----------:|
| seq  |     1 | 0.02618656 | 1.00    | N/A       |
| mpi  |     2 | 0.01326774 | 1.97    | 98.7%     |
| mpi  |     4 | 0.00812840 | 3.58    | 89.5%     |
| mpi  |     6 | 0.00553456 | 5.66    | 94.3%     |

task_run
| Mode | Count | Time, s    | Speedup | Efficiency |
|------|------:|-----------:|--------:|-----------:|
| seq  |     1 | 0.02644370 | 1.00    | N/A       |
| mpi  |     2 | 0.01405612 | 1.88    | 94.2%     |
| mpi  |     4 | 0.00838328 | 3.18    | 79.5%     |
| mpi  |     6 | 0.00734708 | 4.14    | 69.0%     |

На 2 процессах: умеренное/хорошее ускорение (pipeline ≈1.97×, task_run ≈1.88×); высокая эффективность (~94–99%) — но частично это эффект разброса измерений между запусками seq и mpi.
На 4 процессах: стабильное значительное ускорение (pipeline ≈3.58×, task_run ≈3.18×) и хорошая эффективность (~80–90%) — оптимально по соотношению ускорение/эффективность.
На 6 процессах: task_run показывает сильное ускорение (4.14×), pipeline — очень высокое (5.66×), но эффективность для pipeline/task_run варьирует (≈69–94%) и результат чувствителен к вариациям seq-замеров и накладным расходам коммуникаций.

## 8. Conclusions
В ходе работы была успешно реализована как последовательная, так и параллельная версия алгоритма подсчёта предложений в строке с использованием MPI. Разработан корректный алгоритм — обе версии прошли полное функциональное тестирование. Результаты SEQ и MPI реализаций полностью совпадают. Реализована эффективная схема распараллеливания с блочным распределением строки между процессами и корректной обработкой границ между сегментами.
Параллельная реализация демонстрирует хорошее ускорение: на 2 процессах ~1.9–2.0× (эффективность ~94–99%), на 4 процессах ~3.2–3.6× (эффективность ~80–90%), на 6 процессах до 4.1–5.7× с эффективностью ~69–94%. Основное ограничение — коммуникационные накладные расходы и низкая вычислительная плотность задачи. MPI версия эффективна для больших объёмов данных (100 000 предложений, ~3.7 млн символов), а SEQ версия остаётся предпочтительной для строк < 1 млн символов.

## 9. References
1. Материалы курса: <https://learning-process.github.io/parallel_programming_course/ru/common_information/report.html>
2. Microsoft MPI: <https://learn.microsoft.com/ru-ru/message-passing-interface/mpi-reference>
3. OpenMPI документация: <https://www.open-mpi.org/>
4. Сысоев А. В. *Лекции по параллельному программированию*