# Повышение контраста изображения

- **Студент**: Шеметов Даниил Олегович, группа 3823Б1ПР3
- **Технологии**: SEQ | MPI
- **Вариант**: 23

## 1. Введение

Повышение контраста изображения — базовая операция обработки изображений, направленная на усиление различий между светлыми и тёмными областями.

В рамках данной работы реализуется *последовательная* (SEQ) и *параллельная* (MPI) версии алгоритма повышения контраста, а также проводится сравнение производительности.

## 2. Постановка проблемы

**Цель работы:** реализовать алгоритм повышения контраста изображения с использованием *последовательного подхода* (SEQ) и *параллельного подхода* (MPI) с горизонтальным разбиением изображения, провести сравнительный анализ производительности.

## 2. Постановка задачи

**Формальная постановка:**

- Необходимо реализвать структуру, в которая будет описывать каждый пиксель

```
struct Pixel = {
    uint8_t channel_red;
    uint8_t channel_green;
    uint8_t channel_blue;
};
```

- Для изображения `I`, представленного как одномерный массив пикселей `std::vector<Pixel>`, требуется увеличить контраст каждого пикселя с использованием коэффициента `kFactor = 1.3`.

**Входные данные:**
- Изображение в виде одномерного массива пикселей (тип `std::vector<uint8_t>`)  
- Размеры изображения: `width × height × channels`  
- Каждый пиксель представлен `channels` значениями (RGB - 3)  

**Выходные данные:**
- Изображение того же размера с повышенным контрастом (тип `std::vector<Pixel>`)

**Особенности обработки:**
- Контраст усиливается с помощью коэффициента `kFactor = 1.3`  
- Результат ограничен диапазоном `[0, 255]`  
- Параллельная реализация использует MPI с *горизонтальным разбиением данных* 

- *Пример горизонтального разбиения*
```
const size_t total_size = GetInput().size();

std::vector<int> count(size, static_cast<int>(total_size / size));
for (size_t i = 0; std::cmp_less(i, static_cast<int>(total_size % size)); ++i) {
    count[i]++;
}

std::vector<int> displacement(size, 0);
for (int i = 1; i < size; ++i) {
    displacement[i] = displacement[i - 1] + count[i - 1];
}
```

**Ограничения:**
- Размер изображения ограничен доступной памятью  
- Алгоритм должен корректно обрабатывать изображения любого размера  
- Результаты SEQ и MPI версий должны быть идентичны  

## 3. Базовый алгоритм (последовательная версия)

### 3.1. Этапы выполнения задачи

**3.1.1. Валидация данных (`ValidationImpl`):**
- Проверка, что входной массив не пуст

**3.1.2. Предобработка данных (`PreProcessingImpl`):**
- Инициализация выходного массива нужного размера  

**3.1.3. Вычисления (`RunImpl`):**
- Для каждого пикселя:  
  - Умножение на коэффициент `kFactor`  
  - Ограничение диапазона `[0, 255]`  

**3.1.4. Постобработка данных (`PostProcessingImpl`):**
- Проверка, что выходной массив не пуст

### 3.2. Алгоритм последовательной реализации

**Псевдокод:**

```
function RunImpl():
    input = GetInput()
    output = new array[input.size()]

    for i = 0 to input.size() - 1:
        m_red   = local_input.channel_red * kFactor;
        m_green = local_input.channel_red * kFactor;
        m_blue  = local_input.channel_red * kFactor;

        local_output.channel_red   = clamp(m_red,   0.F, 255.F);
        local_output.channel_green = clamp(m_green, 0.F, 255.F);
        local_output.channel_blue  = clamp(m_blue,  0.F, 255.F);

    return true
```

### 3.3. Сложность алгоритма

| Параметр                   | Значение         |
|----------------------------|------------------|
| Временная сложность        | O(n)             |
| Пространственная сложность | O(n)             |

## 4. Параллельная реализация (MPI)

### 4.1. Стратегия распараллеливания

**Горизонтальное разбиение изображения:**  
- Изображение делится на полосы по строкам  
- Каждая полоса обрабатывается отдельным процессом MPI  
- После обработки результаты собираются процессом 0

### 4.2. Алгоритм параллельной реализации

**Псевдокод:**

```
function RunImpl():
    rank = MPI_Comm_rank()
    size = MPI_Comm_size()

    std::vector<int> count(size, total_size / size);
    for i = 0 to i < total_size % size
        count[i]++;

    std::vector<int> displacement(size, 0);
    int i = 1 to i < size
        displacement[i] = displacement[i - 1] + count[i - 1];

    std::vector<int> count_to_bytes(size);
    std::vector<int> displacement_to_bytes(size);

    for i = 0 to i < size
        count_to_bytes[i]        = count[i] * sizeof(Pixel);
        displacement_to_bytes[i] = displacement[i] * sizeof(Pixel);

    local_input  = new array[counts[rank]]
    local_output = new array[counts[rank]]

    MPI_Scatterv(GetInput(), count_to_bytes, displacement_to_bytes, local_in)

    for i = 0 to local_in.size() - 1:
        m_red   = local_input.channel_red * kFactor;
        m_green = local_input.channel_red * kFactor;
        m_blue  = local_input.channel_red * kFactor;

        local_output.channel_red   = clamp(m_red,   0.F, 255.F);
        local_output.channel_green = clamp(m_green, 0.F, 255.F);
        local_output.channel_blue  = clamp(m_blue,  0.F, 255.F);

    MPI_Gatherv(local_output, count_to_bytes, displacement_to_bytes, GetOutput())
    MPI_Barrier()

    return true
```

### 4.3. Коммуникационные операции

1. **MPI_Scatterv** — распределение полос изображения  
2. **MPI_Gatherv** — сбор обработанных данных обратно на процесс 0  
3. **MPI_Barrier** — синхронизация процессов  

### 4.4. Сложность параллельной реализации

| Параметр                  | Значение           |
|----------------------------|------------------|
| Временная сложность        | O(n / size + Коммуникации) |
| Пространственная сложность | O(n / size) |

*где:* 
- `n` - общее количество пикселей изображения
- `size` — количество процессов MPI.
- Коммуникации - (`MPI_Scatterv` + `MPI_Gatherv`)

## 5. Экспериментальные результаты

### 5.1. Тестовая конфигурация

- **Размеры тестовых изображений:** 2×2, 545×360, 245×148, 209×148 - *пикселей*
- **Количество каналов:** 3 (RGB)  
- **Тесты производительности:** 100, 1000, 10000, 100000, 1000000 - *одна сторона изображения*

### 5.2. Функциональные тесты

- Все функциональные тесты проходят успешно для SEQ и MPI  
- Результаты прохождения тестов идентичны
 
### 5.3. Тесты производительности

- Для тестов "создадим" изображение размером `1024 * 1024` пикселей. Таким образом, необходимо обработать `1048576` пикселей

| Режим               | SEQ, ms | MPI (4 процесса), ms  | MPI (2 процесса), ms  | MPI (1 процесс), ms   |
|---------------------|--------:|----------------------:|----------------------:|----------------------:|
| Full cycle          | 1       | 1                     | 1                     | 1                     |
| Run only            | 0       | 0                     | 0                     | 0                     |
| Small image         | 1       | 1                     | 1                     | 1                     |
| Large image         | 873     | 886                   | 824                   | 807                   |
| Various images      | 88      | 94                    | 90                    | 88                    |

## 6. Анализ результатов

### 6.1. Корректность реализации

- Все функциональные тесты пройдены  
- Результаты SEQ и MPI идентичны  
- Ограничение значений пикселей диапазоном `[0, 255]`

### 6.2. Производительность

- Последовательная версия: O(n), где `n` - количество пикселей
- Параллельная версия: ускорение ≈ `size` при больших данных  
- Горизонтальное разбиение обеспечивает балансировку нагрузки

### 6.3. Узкие места

- Коммуникация MPI (Затраты времени на рапсределение и сбор данных)
- Обработка маленьких массивов неэффективна

## 7. Выводы

1. Реализованы SEQ и MPI версии повышения контраста  
2. Горизонтальное разбиение *обеспечивает эффективное распараллеливание*  
3. Все функциональные тесты *проходят успешно*  
4. MPI версия *демонстрирует масштабируемость*

## 8. Приложение

### Приложение 1: Реализация последовательной версии алгоритма

См. файл `seq/src/ops_seq.cpp`.

### Приложение 2: Реализация параллельной версии алгоритма

См. файл `mpi/src/ops_mpi.cpp`.